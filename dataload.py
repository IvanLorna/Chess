# -*- coding: utf-8 -*-
"""DataLoad.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pOvKeq-ArGMQKHEkcp_4jne-nxlML3bT
"""

import chess
import numpy as np
import pandas as pd
import os

def DataLoad():
  if os.path.exists('/content/games.csv'):
    dataframe = pd.read_csv('games.csv')
    dataframe = dataframe[dataframe['victory_status']== 'mate']
    dataframe_black = dataframe[dataframe['winner'] == 'black']
    dataframe_white = dataframe[dataframe['winner'] == 'white']
    return np.array(dataframe_white['moves']), np.array(dataframe_black['moves'])
  else:
    print("Please upload the games.csv file to load the data")
    return [None], [None]

squares_index = {
  'a': 0,
  'b': 1,
  'c': 2,
  'd': 3,
  'e': 4,
  'f': 5,
  'g': 6,
  'h': 7
}

def square_to_index(square):
    letter = chess.square_name(square)
    return 8 - int(letter[1]), squares_index[letter[0]]

def split_dims(board):
  # this is the 3d matrix
    board3d = np.zeros((14, 8, 8), dtype=np.int8)

  # here we add the pieces's view on the matrix
    for piece in chess.PIECE_TYPES:
        for square in board.pieces(piece, chess.WHITE):
            idx = np.unravel_index(square, (8, 8))
            board3d[piece - 1][7 - idx[0]][idx[1]] = 1
        for square in board.pieces(piece, chess.BLACK):
            idx = np.unravel_index(square, (8, 8))
            board3d[piece + 5][7 - idx[0]][idx[1]] = 1

  # add attacks and valid moves too
  # so the network knows what is being attacked
    aux = board.turn
    board.turn = chess.WHITE
    for move in board.legal_moves:
        i, j = square_to_index(move.to_square)
        board3d[12][i][j] += 1
    board.turn = chess.BLACK
    for move in board.legal_moves:
        i, j = square_to_index(move.to_square)
        board3d[13][i][j] += 1
    board.turn = aux
    return board3d

def move_dims(move):
  board3d = np.zeros((2,8,8), dtype= np.int8)
  i = squares_index[move[0]]
  j = 8 - int(move[1])
  board3d[0][j][i] = 1
  i = squares_index[move[2]]
  j = 8 - int(move[3])
  board3d[1][j][i] = 1
  return board3d

def BoardBeforeMove(board, move):
  dims = split_dims(board)
  UCI = chess.Move.uci(board.parse_san(move))
  board.push_uci(UCI)
  return dims, move_dims(UCI), UCI

def moves(game, type):
  Steps = game.split(' ')
  board = chess.Board()
  game = []
  moves = []
  i = 0
  for step in Steps:
    if (type == "white"):
      if (i % 2) == 0: 
        dims, UCI_board, UCI = BoardBeforeMove(board,step)
        moves.append(UCI_board)
        game.append(dims)
      else:
        a, b, c = BoardBeforeMove(board,step)
    else:
      if (i % 2) != 0:
        dims, UCI_board, UCI = BoardBeforeMove(board,step)
        moves.append(UCI_board)
        game.append(dims)
      else:
        a, b, c = BoardBeforeMove(board,step)
    i += 1
  return np.array(game), np.array(moves)

def GetData():
  WhiteWin = []
  WhiteMoves = []
  BlackWin = []
  BlackMoves = []
  wgames, bgames = DataLoad()
  if np.array(wgames).any() is None:
    return [None], [None], [None], [None]
  for game in wgames:
    WW, WM = moves(game, "white")
    WhiteWin.append(WW)
    WhiteMoves.append(WM)
  for game in bgames:
    BW, BM = moves(game, "black")
    BlackWin.append(BW)
    BlackMoves.append(BM)
  
  return WhiteWin, WhiteMoves, BlackWin, BlackMoves

def PreprocessData(WX,WY,BX,BY):
  if WX[0] is None:
    return None, None, None, None
  TrainWX = []
  TrainWY = []
  TrainBX = []
  TrainBY = []
  for game, move in zip(WX,WY):
    for i in range(len(game)):
      TrainWX.append(game[i].reshape(8,8,14))
      TrainWY.append(move[i].reshape(1,128))

  TrainWX = np.array(TrainWX)
  TrainWY = np.array(TrainWY)


  for game, move in zip(BX,BY):
    for i in range(len(game)):
      TrainBX.append(game[i].reshape(8,8,14))
      TrainBY.append(move[i].reshape(1,128))

  TrainBX = np.array(TrainBX)
  TrainBY = np.array(TrainBY)
  return TrainWX, TrainWY, TrainBX, TrainBY