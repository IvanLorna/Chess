# -*- coding: utf-8 -*-
"""AI_class.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19808imAEAdHna9zpJkeknI-Okk3-2cJ4
"""

import os
import pandas as pd
import keras
import chess
import chess.engine
import numpy as np
from dataload import split_dims, squares_index
import Model
from tensorflow.keras import models, layers
import tensorflow as tf
from stockfish import Stockfish




class WhiteAgent():
  def __init__(self, load = False, TrainWX = None, TrainWY = None):
    if load:
      self.Models = [models.load_model("/content/White Weights/WModel1.h5"), models.load_model("/content/White Weights/WModel2.h5"),
      models.load_model("/content/White Weights/WModel3.h5"),models.load_model("/content/White Weights/WModel4.h5"),
      models.load_model("/content/White Weights/WModel5.h5"),models.load_model("/content/White Weights/WModel6.h5"),
      models.load_model("/content/White Weights/WModel7.h5"),models.load_model("/content/White Weights/WModel8.h5"),
      models.load_model("/content/White Weights/WModel9.h5"),models.load_model("/content/White Weights/WModel10.h5"),
      models.load_model("/content/White Weights/WModel11.h5"),models.load_model("/content/White Weights/WModel12.h5"),
      models.load_model("/content/White Weights/WModel13.h5"),models.load_model("/content/White Weights/WModel14.h5"),
      models.load_model("/content/White Weights/WModel0.h5")]

    else:
      if os.path.exists('/content/games.csv'):
        self.Models = Model.TrainModels(TrainWX, TrainWY, isWhite = True)
      else:
        self.Models = None
    self.weights = np.ones(15)

class BlackAgent():
  def __init__(self, load = False, TrainBX = None, TrainBY = None):
    if load:
      self.Models = [models.load_model("/content/Black Weights/BModel1.h5"), models.load_model("/content/Black Weights/BModel2.h5"),
      models.load_model("/content/Black Weights/BModel3.h5"),models.load_model("/content/Black Weights/BModel4.h5"),
      models.load_model("/content/Black Weights/BModel5.h5"),models.load_model("/content/Black Weights/BModel6.h5"),
      models.load_model("/content/Black Weights/BModel7.h5"),models.load_model("/content/Black Weights/BModel8.h5"),
      models.load_model("/content/Black Weights/BModel9.h5"),models.load_model("/content/Black Weights/BModel10.h5"),
      models.load_model("/content/Black Weights/BModel11.h5"),models.load_model("/content/Black Weights/BModel12.h5"),
      models.load_model("/content/Black Weights/BModel13.h5"),models.load_model("/content/Black Weights/BModel14.h5"),
      models.load_model("/content/Black Weights/BModel0.h5")]

    else:
      if os.path.exists('/content/games.csv'):
        self.Models = Model.TrainModels(TrainBX, TrainBY, isWhite = False)
      else:
        self.Models = None
    self.weights = np.ones(15)

class Agent():
  def __init__(self, isWhite = True):
    if os.path.exists("/content/White Weights") is False or os.path.exists("/content/Black Weights") is False:
      TrainWX, TrainWY, TrainBX, TrainBY = dataload.PreprocessData(*dataload.GetData())
      self.BlackAgent = BlackAgent(load = False, TrainBX = TrainBX, TrainBY = TrainBY)
      self.WhiteAgent = WhiteAgent(load = False, TrainWX = TrainWX, TrainWY = TrainWY) 
    else:
      self.BlackAgent = BlackAgent(load = True)
      self.WhiteAgent = WhiteAgent(load = True)
    
    self.Side = isWhite
    
    #load stockfish
    if os.path.exists("/content/stockfish/stockfish") is True:
      self.stockfish = Stockfish("/content/stockfish/stockfish")
    else:
      print("Content Missing at path '/content/stockfish/stockfish'. Unable to load.")

  def moveEval(self, pred, move):
    UCI = str(move)
    i = squares_index[UCI[0]]
    j = 8 - int(UCI[1])
    k = squares_index[UCI[2]]
    l = 8 - int(UCI[1])
    return pred[0][j][i]*pred[1][l][k]

  #evaluate move made on board using stockfish
  def voteEval(self,board,depth,move):
    board.push_uci(move)
    with chess.engine.SimplEngine.popen_uci('/content/stockfish/stockfish') as sf:
      result =  sf.analyse(board, chess.engine.Limit(depth=depth))
      score = result['score'].white().score()
      return score

  #determine stockfish's best move to make on current board
  def getBestMoveSF(board):
    self.stockfish.set_fen_position(board.fen())
    return self.stockfish.get_best_move()

  def Decision(self, Board, model):
    X = []
    X.append(split_dims(Board).reshape(8,8,14))
    X= np.array(X)
    prediction = model.predict(X[:1])
    curr_move = ""
    max = 0
    prediction = prediction.reshape(2,8,8)
    for move in Board.legal_moves:
      curr = self.moveEval(prediction,move)
      if curr > max:
        curr_move = move
        max = curr
    return curr_move

  def MakeMove(self, board):
    if self.Side is True:
      Models = self.WhiteAgent.Models
      weights = self.WhiteAgent.weights
    else:
      Models = self.BlackAgent.Models
      weights = self.BlackAgent.weights
    tf.compat.v1.logging.set_verbosity(tf.compat.v1.logging.ERROR)
    consensus = [str(self.Decision(board, Models[i])) for i in range(15)]
    Options = list(set(consensus))
    vote = []
    for i in range(len(Options)):
      count = 0
      for j in range(len(consensus)):
        if consensus[j] == Options[i]:
          count += weights[j]
      vote.append(count)
    Move = Options[np.argmax(vote)]
    return Move